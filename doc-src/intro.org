#+STARTUP: inlineimages header
#+PROPERTY: header-args :cache yes :exports both


#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css" integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ" crossorigin="anonymous"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/criterium.css" />

* Microbenchmark with Criterium

If you want to know how a single part of your code base performs, you
can turn to ~clojure.core/time~

** Clojure's built in ~time~ macro

We can use clojure's build in ~time~ macro to time an arbitrary
expression.

#+begin_src clojure :results output
(clojure.core/time (Thread/sleep 1))
#+end_src

#+RESULTS:
: "Elapsed time: 1.42248 msecs"


That may look inaccurate, but ~Thread/sleep~ doesn't have great accuracy.

Let's try something a little simpler, like timing a constant
expression.

#+begin_src clojure :results output
(clojure.core/time 1)
#+end_src

#+RESULTS:
: "Elapsed time: 0.031854 msecs"

Hundreds of microseconds for a constant is a little large.  This is
effectively a one-shot measurement, and the first time the JIT runs
enything, it takes much longer than on subsequent runs.

** Criterium ~time~

Criterium provides a ~time~ macro that we can use as a replacement for
clojure core's ~time~.  For quick functions, it provides much
different answers

#+begin_src clojure :results output
(do
  (require '[criterium.time :as criterium])
  (criterium/time 1))
#+end_src

#+RESULTS:
:                         Elapsed Time: 0.849 ns  3σ [0.800 0.898]  min 0.835

There are several orders of magnitude difference here.  Criterium's time
by default does some warmup on quick functions to activate the JIT
compiler.  We can tell Criterium to use a one shot measurement.

#+begin_src clojure :results output
(criterium/time 1 :sample-scheme :one-shot)
#+end_src

#+RESULTS:
:                     Elapsed time: 266 ns

We see there is now just a 3 order of magnitude difference.

Clojure's ~time~ stops timing as an argument to a prn call.  We can see
the difference by creating a slightly modified version of clojure's
~time~.

#+begin_src clojure :results output
(do
  (defmacro ttime
    [expr]
    `(let [start#  (. System (nanoTime))
           ret#    ~expr
           finish# (. System (nanoTime))]
       (prn
        (str "Elapsed time: "
             (/ (double (- finish# start#)) 1000000.0)
             " msecs"))
       ret#))
  (ttime 1))
#+end_src

#+RESULTS:
: "Elapsed time: 3.25E-4 msecs"


This is now much more comparable, being the same order of magnitude as
criterium's one-shot sample.

Another difference, in more complex expressions, is due to how criterium
lifts constants out of the timing loop.

** Controlling how hard criterium tries to get an answer

Often we see people putting their expressions in a loop, and then
adjusting the number of iterations to run to give an answer in a
reasonable time.

We can achieve the same effect by using the `:limit-time-s` options to
criterium's ~time~, to limit the time in seconds that criterium will
use.


#+begin_src clojure :results output
(criterium/time 1 :limit-time-s 0.00001)
#+end_src

#+RESULTS:
:                         Elapsed Time: 188 ns  3σ [-247 623]  min 82.0

In this case Criterium displays a mean and variance.

When the time is limited, then criterium will often show a compilation
warning.  This means that JIT compilation took place during the timing
loop, and is causing an inaccurate answer.  In this case, giving
criterium a higher time limit will result in an estimate once JIT has
completed, and reduce the three sigma range of the estimate.

#+begin_src clojure :results output
(criterium/time 1 :limit-time-s 10)
#+end_src

#+RESULTS:
:                         Elapsed Time: 1.03 ns  3σ [0.933 1.13]  min 1.00


** Examining Time Distribution

The mean and variance displayed are not always useful.  The distribution
tends to have a hard lower bound and a long tail, making it skewed. An
example of this is that the lower bound of the 3 sigma estimate is often
below the minimum measurement.

To give more insight, we can ask criterium to plot the distribution.

For this to work you will need ~criterium/chart~ on your classpath.

#+begin_src clojure :results silent
(criterium/time 1 :limit-time-s 1 :histogram true)
#+end_src

#+begin_src clojure :exports results :results file graphics :dir "data/images" :file "histogram.png" :var dir=(concat (file-name-directory (buffer-file-name)) "data/images/")
(criterium/time
 1
 :limit-time-s 1
 :histogram {:file "doc-src/data/images/histogram.png"})
#+end_src

#+RESULTS:
[[file:data/images/histogram.png]]


** Using CPU Time rather than Elapsed Time

Using CPU time, if available, may produce less variation in the
timings.  However, the cpu time often has less accuracy, and may require
lareger execution limits.

#+begin_src clojure :results output
(do
  (require '[criterium.jvm :as jvm])
  (criterium/time 1 :time-fn jvm/current-thread-cpu-time))
#+end_src

#+RESULTS:
:                         Elapsed Time: 1.15 ns  3σ [1.00 1.30]  min 1.12
